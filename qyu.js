/*
** qyu.js
**
** Made by Alexis ROLLAND
**
*/

const EventEmitter = require('events');

function qyu({rateLimit, statsInterval}) {
  return new QYU(rateLimit, statsInterval);
}

/**
 * QYU: An in-memory queue handling job with priorities
 * When several tasks are added with the same priority they are consumed on a FIFO mode
 *
 * 6 event types can be emitted:
 *   done(id, result)         a job is done, id being the internal job identifier and result the job result
 *   all-done():              all currently running jobs are over
 *   error(id, error)         a job failed, id being the internal job identifier and error the thrown exception
 *   drain()                  the job queue is empty. Some job can still be running
 *   stats(nbJobsPerSecond)   the number of job processed by second. The timer only stops when all jobs are over
 *   rateLimit-reached       number of jobs currently processed reach rate limit
 */
class QYU extends EventEmitter {
  constructor(rateLimit = 50, statsInterval = 3000) {
    super();
    this.rateLimit = rateLimit; // maximum number of jobs being processed at the same time
    this.statsInterval = statsInterval; // when stat event is sent, in ms
    this._nextId = 0; // next task identifier which will be assigned
    this._running = false; // _running is false only if qyu have never been started or if queue has been drained
    this._paused = true; // _paused is true only at initialization and when pause method is called
    this._qlen = 0; // number of object in queue
    this._queue = {}; // contains one array of ids for each of the 10 priorities
    this._tasks = {}; // map of awaiting tasks: id => job
    this._runningJobs = {}; // map of running jobs: id => promise
    this._completedJobs = {}; // map of job results: id => jobResult
    this._nbJobsRunning = 0; // number of currently running jobs
    this._nbJobsCompleted = 0; // nuber of completed jobs
    this._startTime = null; // last running/unpaused timestamp
    this._runningTime = 0; // Cumulated running time, without idle time
    this._statsPusher = null;
  }

  /**
   * Pauses consumption of the queue
   * @returns {Number}  Number of task remaining in queue
   */
  async pause() {
    this._paused = true;
    clearInterval(this._statsPusher);
    return this._qlen;
  }

  /**
   * Push a new job into the queue
   * @param {requestCallback} job           job to push in the queue
   * @param {Number}          [priority=5]  the priority given to the job, must be an integer between 1 and 10
   * @returns {Number}                      the interal identifier of the job generated by QYU
   */
  push(job, priority = 5) {
    if (Number.isInteger(priority) == false ||
        priority < 1 || priority > 10) {
      throw new Error("priority must be an integer between 1 and 10");
    }
    this._qlen++;
    if (this._queue[priority] == undefined) {
      this._queue[priority] = [];
    }
    this._queue[priority].push(this._nextId);
    this._tasks[this._nextId] = job;
    this._worker(); // if not yet running and not paused, the worker will resume its work
    return this._nextId++;
  }

  /**
   * Starts consumption of the queue by priority given to jobs
   */
  async start() {
    this._paused = false;
    this._createStatsPusher();
    this._worker();
  }

  /**
   * Wait for the resolution the job result of a task in progress or completed
   * @returns   a job result
   */
   async wait(id) {
    // Let's verify that id is a valid value
    if (Number.isInteger(id) == false) {
      throw new Error('Given job identifier must be an integer');
    }

    // Let's verify is this job has not already been completed to return the result
    if (this._completedJobs[id] != undefined) {
      return this._completedJobs[id];
    }

    if (this._runningJobs[id] != undefined) {
      return await this._runningJobs[id].then((jobResult) => {
        return jobResult;
      });
    }

    if (this._tasks[id] != undefined) {
      throw new Error(`Task ${id} which has not yet been started`);
    }

    throw new Error(`Job with id ${id} does not exists`);
  }

  /* Internal methods below this comment */

  /**
   * Retrieve next task to consume and remove it from the queue
   * @returns {Object}  contains the job and its identifier
   */
  _getNextTask() {
    if (this._qlen == 0) {
      return null;
    }
    for (var i = 1; i <= 10; i++) {
      if (this._queue[i] != undefined && this._queue[i].length) {
        const id = this._queue[i].shift();
        const job = this._tasks[id];
        delete this._tasks[id];
        this._qlen--;
        return {id, job};
      }
    }
    return null; // this should never happen
  }

  /**
   * The worker which is unqueueing jobs.
   * Its will automatically end if no more item are in the queue or rateLimit is
   * reached and will be recalled, if needed, by push method or when a free job
   * spot will be available.
   */
  _worker() {
    if (this._running == false && this._qlen) { // worker is already working when running is true or queue is empty
      this._running = true;
      this._resumeStatsTimer();
      while (this._running == true && this._paused == false) {
        if (this._qlen == 0) {
          this.emit('drain');
          this._running = false;
        } else if (this._nbJobsRunning < this.rateLimit) {
          var task = this._getNextTask();
          if (task) {
            this._runningJobs[task.id] = this._runJob(task);
          }
        } else {
          this.emit('rateLimit-reached');
          this._running = false;
        }
      }
      this._running = false;
    }
  }

  /**
   * Handling end of a job
   */
  _jobOver() {
    this._nbJobsRunning--;
    if (this._nbJobsRunning == 0) {
      this.emit('all-done');
      this._holdStatsTimer();
    }
    this._nbJobsCompleted++;
    this._worker();
  }

  /**
   * Runs a new job
   * @returns  a Promise with the job result
   */
  async _runJob({id, job}) {
    this._nbJobsRunning++;
    return await job().then((jobResult) => {
      this.emit('done', id, jobResult);
      this._completedJobs[id] = jobResult;
      this._jobOver();
      return jobResult;
    }).catch ( (error) => {
      this.emit('error', id, error);
      this._jobOver();
      throw error;
    });
  }

  /**
   * Creates a stats emitter
   */
  _createStatsPusher() {
    if (this._statsPusher == null) {
      this._statsPusher = setInterval(() => {
        var elapsedTime = this._runningTime;
        if (this._startTime != null) {
          elapsedTime += Math.round(Date.now() / 1000) - this._startTime;
        }
        const nbJobsPerSecond = (this._nbJobsCompleted / elapsedTime).toFixed(4);
        this.emit('stats', nbJobsPerSecond);
        if (this._qlen == 0 && this._nbJobsRunning == 0) {
          this._removeStatsPusher();
        }
      }, this.statsInterval);
    }
  }

  /**
   * Removes the stats emitter
   */
  _removeStatsPusher() {
    if (this._statsPusher) {
      this._holdStatsTimer();
      clearInterval(this._statsPusher);
      this._statsPusher = null;
    }
  }

  /**
   * Start the stats timer in order to only calculate effective work time
   */
  _resumeStatsTimer() {
    if (this._startTime == null) {
      this._startTime = Math.round(Date.now() / 1000);
    }
  }
  /**
   * Pauses the stats timer in order to only calculate effective work time
   */
  _holdStatsTimer() {
    if (this._startTime != null) {
      this._runningTime += Math.round(Date.now() / 1000) - this._startTime;
      this._startTime = null;
    }
  }
}

module.exports = qyu;
