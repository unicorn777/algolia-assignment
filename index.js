const qyu = require('./qyu');

const q = qyu({
  rateLimit: 50, // maximum number of jobs being processed at the same time
  statsInterval: 3000 // When stat event is sent, in ms
});

q.on('done', function ( id, result ) {
  console.log(`Job done ${id}`); // `id` is an internal identifier generated by `qyu`
});

q.on('all-done', function() {
  console.log('All jobs are done');
});

q.on('error', function ( id, error ) {
  console.log(`Job ${id} threw an error: ${error.message}`);
});

q.on('drain', function () {
  console.log('No more jobs to do');
});

q.on('stats', function ( nbJobsPerSecond ) {
  console.log(`${nbJobsPerSecond} jobs/s processed`)
});

(async () => {

  /* Testing priorities */
  var id = null;
  console.log("Testing priorities: should, in order get tasks : 5, 8, 3, 2, 10, 9, 11, 4, 1, 6, 7, 0");
  [10, 7, 4, 3, 6, 1, 8, 9, 2, 5, 4, 5].forEach((priority) => {
    id = q.push(
      job, // function to execute
      priority   // optional priority, from 1 to 10, 1 being the highest priority - default: 5
    ); // returns the internal id
    console.log(`Job ${id} with priority ${priority} pushed`);
  });

  await q.pause(); // returns a promise resolved when `q` has paused (no jobs being processed)
  await q.start(); // returns a promise resolved when `q` has started (first time) or unpaused
  await q.wait(id);

  await q.pause();

  /* Testing wait method (ids 12 to 20) */
  const idBeforeStart = q.push(job);
  // const res1 = await q.wait(idBeforeStart); // XXX TODO
  await q.start();
  const idAfterStart = q.push(longJob);
  const res2 = await q.wait(idAfterStart);
  // console.log(`expecting "world!": ${res1.Hello}`);
  console.log(`expecting "It was a looong job": ${res2.Hello}`);
  await q.pause();

  /* Testing rate Limit */
  for (var i = 0; i < 400; ++i) {
    q.push(randJob, Math.floor(Math.random() * 10) + 1);
  }
  await q.start();

  
  /* Testing error cases */
  console.log("Testing pushing a job with an invalid priority");
  try { q.push(job, '15'); } catch (error) { console.log(error); } // bad priority type or value
  try { q.push(nonExistingFunc) } catch (error) { console.log(error) } // job function does not exist
  // TODO: test q.wait() with a non-existent id


 // const res = await q.wait(id); // resolves when the job is complete with the job result // XXX TODO!
})();

// example job:

async function job() {
  await wait(30);
  console.log('PWET');
  return {Hello: 'world!'} // That's the job `result`
}

async function longJob() {
  await wait(5000);
  return {Hello: 'It was a looong job'} // That's the job `result`
}

async function randJob() {
  var seconds = (Math.floor(Math.random() * 3) + 1);
  await wait(seconds * 1000);
  return {Hello: 'Milliseconds matter'} // That's the job `result`
}

function wait(ms) {
  return new Promise((resolve) => {
    return setTimeout(resolve, ms)
  });
}
